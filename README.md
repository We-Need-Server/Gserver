일단 클라이언트와 서버 사이에서 어떠한 과정이 있는지 말을 해보자.

클라이언트는 자신의 프레임마다 UDP 패킷을 보낼 것이다.

패킷에는 어떠한 내용이 들어갈까?

타입이 명시되어 있지 않다면 기본적으로 양의 정수를 가지고 있다고 판단한다.
- Flag(1BYTE) => 패킷의 ACK를 참조할 지, SEQ를 참조할 지, 서버와 연결을 종료하고 싶어하는지, 연결을 하고 싶어하는지 나타낸다.(패킷을 표현하는데 8자리를 사용한다. 기본적으로 플래그를 A~H(8개)까지 가지고 있다고 해보자 255은 11111111을 나타내고 이렇게 되면 모든 플래그가 다 켜졌다고 볼 수 있다. => 어떻게 설정할지는 여러 상황을 고려해봐야 할 거 같다.) => 제어용 패킷은 TCP로 가자.
- SEQ(4바이트) => 패킷의 번호를 나타낸다.
- ACK(4바이트) => 패킷의 확인 번호를 나타낸다.
- QPORT(1BYTE) => 패킷이 어떤 플레이어로부터 왔는지 구분하는데 사용한다.
- PKind(1BYTE, 문자) => 패킷을 구분하는 데 사용한다.
- COMMAND(2BYTE, 문자) => 페이로드가 몇 바이트를 가지고 있는지 나타낸다.(이걸 표시해야 하는 이유는 페이로드 안의 바이트의 제약을 두고 싶지 않고 확장성 있게 처리하고 싶어서다.)
- PAYLOAD(?BYTE) => 실제 클라이언트의 패킷 내용(커맨드에 따라 어떤 종류의 내용을 담고 있는지 달라진다.)

서버는 해당 UDP 패킷이 오면 이를 버퍼에 저장한다.
그리고 무한 루프로 돌아가고 있는 고루틴이 버퍼에 패킷이 왔다는 것을 확인하면, 버퍼에서 패킷을 빼고 이를 분석한다.
이를 분석할 때 4바이트, 4바이트, 1바이트, 1바이트, 1바이트, 2바이트, 커맨드 규칙에 따른 바이트로 파서한다.

# 연결이 시작되는 부분(이 부분은 임시이기 때문에 나중에 바뀔 가능성이 아주 농후하다.(지금 임시로 테스트해야 하기 때문에 게임 서버가 유저의 첫 연결을 보고 게임 캐릭터를 바로 만들어야 하기 때문이다.))
각 유저가 게임을 시작하기 전 처음 서버와 연결하기 위해 첫 UDP 패킷을 보낼 때를 고려해보자.
유저는 패킷을 어떻게 보낼까?

아무래도 이러한 구조를 보낼 것이다.
- Flag: 128(10000000)
- PAYLOAD: 클라이언트 UDP 서버의 리슨IP및 PORT
  FLAG가 128이라는 것을 확인하면, 사용자를 등록하는 과정을 진행해야 한다.

이때 HandleNewConnection 함수를 호출하고 인자로 UserRemoteAddr를 받는다.
HandleNewConnection 함수에서 QPPORT 값을 랜덤으로 발급 받고
이를 Map객체에 넣어서 Key:Value로 보관한다.(QPORT, 클라이언트 UDP 서버의 리슨IP및 PORT) 그리고 이러한 Map객체를 IpTable이라고 지정한다.
HandleNewConnection 함수에서 Game 패키지의 CreatePlayer 함수를 통해 이후 게임 객체에 플레이어 객체를 하나 생성하고 초기화한다.
그리고 만들어진 플레이어 객체를 Map객체로 만들어 Key:Value(QPORT, Player) 형태로 참조하게 한다. 그리고 이러한 Map 객체를 PlayerTable이라고 한다.
이 모든 일들은 Game 객체 안에서 이루어지는 일이다.
또한 시퀀스 넘버를 네트워크 객체 안에서 만들고 map 객체로 만든다.(QPORT, SEQ) 이를 가리키는 포인터를 ClientGoroutine 구조체에 넣어준다.

그리고 네트워크 객체는 고루틴과 통신하기 위한 채널을 하나 만들고 해당 채널을 기반으로 한 ClientGoroutine 구조체를 만든다.
ClientGoroutine 구조체는 다음과 같을 것이다.
{
// 패킷을 받을 Byte Slice
// 시퀀스 번호 포인터(네트워크 객체에서 받는다. 이는 각 클라이언트의 패킷 시작 번호가 된다.)
// 네트워크 객체와 통신할 Channel
}
![img.png](img.png)
그리고 만들어진 채널을 채널들을 보관하는 맵 객체인 ChannelTable에 저장한다.(QPORT, Channel)
그리고 StartClientGoroutine 함수를 gorouine으로 실행시킨다.
StartClientGoroutine 함수는 ClientGoroutine 구조체를 인자로 받고 for 무한 루프를 통해 채널을 확인한다.
그리고 채널에서 들어온 메시지를 보고 Player에 대한 패킷을 처리하기 위해 Game 객체나 네트워크 객체의 함수를 호출한다.

이렇게 만들어졌다면 클라이언트한테 반환 패킷을 보내야 할 것이다.
반환 패킷은 다음과 같다.
- SEQ(4바이트) => 서버가 앞으로 시작한 패킷의 시작번호를 나타낸다.(유저는 해당 번호 + 1로 다음 패킷을 보내야 한다.)
- ACK(4바이트) => 1(유저의 연결을 정상적으로 받았고 플레이어가 생성되었다.)
- Flag(1Byte) => 미정
- QPORT(1BYTE) => 발급받은 QPORT 값

이 응답을 받은 클라이언트는 패킷을 파싱하고 이제부터는 서버의 패킷 번호로 통신하게 될 것이다.

# 게임 중 패킷에 대해서 클라이언트가 네트워크 객체에 보낼 때 처리 방식
네트워크 객체는 Parsing 후 각 클라이언트에 해당하는 패킷을 고루틴에게 채널을 통해 넘겨준다.
파싱된 패킷을 받은 각 클라이언트 담당 고루틴은 일단 시퀀스 넘버를 확인한다. 현재 시퀀스 넘버 + 1과 같지 않을 경우 패킷을 무시한다.
만약 같을 경우 처리를 시작한다. 처리를 완료하고 +1을 해준다.(게임 내용에 대한 업데이트는 전부 게임 객체에서 처리한다. 총 이벤트도 포함한다.)


# 틱 시스템에 대한 구현
일단 우선적으로 게임 객체는 자신의 상태를 직렬화할 수 있는 함수가 존재해야 하고
게임 객체 내부에서 이전 틱에 있었던 게임 상태를 보관할 수 있는 변수가 필요하다.(일단 여러 개의 틱을 저장하려고 하지 말고, 이전 틱만 저장하도록 구현해보자. => 그거 아님 배열로 보관해야 함)
1초에 60틱을 가지고 있어야 하며,
네트워크 객체의 QPORT 테이블을 활용하여, IP 정보를 획득하여 직렬화된 게임 상태를 브로드캐스팅 할 수 있어야 한다.
그러므로 틱 시스템은 세 가지를 가지고 있어야 한다.(QPORT:IP 맵 객체, QPORT:SEQ 맵 객체, GAME 직렬화 값)
해당 브로드캐스팅은 UDP를 통해 진행될 것이다.

# 클라이언트의 UDP 서버 STUN 알아내기
STUN 서버를 활용해서 자신이 연 UDP 서버에 대한 공인 IP와 포트를 알아내야 한다.
공인에서 제공하는 STUN 서버가 있으니 그것을 사용해서 공인 IP와 포트를 알아내고 해당 정보를 나에게 전달해야 한다.

클라이언트 UDP => 클라이언트 서버소켓임
서버를 열었음 => UDP 포트 != 클라이언트로서 게임 서버에 보내는 UDP 포트
클라이언트 이벤트 패킷 => 공인 IP, Port
로컬호스트 9000번열거임 => 9000번 리스닝 포트 => NAT 공인 IP의 다른 포트

# 추신
만약 3번틱 시점에 UDP 패킷이 보내졌다고 했다면 그걸 58번틱 시점에 처리하는게 맞을까?

지금까지 고려되었던 문제는 다음과 같다.
1초에 60틱
만약 48번틱 떄의 게임 정보가 클라이언트들에게 보내지고 48번틱을 기준으로 총을 쐈다면, 이건 어떻게 처리하는가.
해당 논의의 결론은 48번틱을 기준으로 처리하는 것이었다.
이게 타당하다고 생각한 이유는 문제의 시발점은 기준이 되는 48번틱을 기점으로 이루어지기 때문이다.

하지만 이번 문제는 좀 다르다.
3번틱을 기준으로 UDP 패킷이 보내졌을 때(시퀀스 3번), 그게 서버의 48번틱을 보내고 49번틱을 처리해야 되는 시점에 도착했다면 48번틱을 기준으로 처리해야 하는가?
이건 말이 안된다. 아무래도 3번틱을 기준으로 처리해야 한다.
근데 어떻게 3번틱을 기준으로?
그래서 배열을 만든다. 1초의 60틱이므로 60틱을 보관할 수 있는 배열을 만든다.
그리고 각 배열의 요소 안에 타임스탬프를 넣어두어 해당 틱이 저장된 시점을 기록한다.

이후 클라이언트가 이벤트 요청을 보낼때 페이로드에 현재 기준의 틱 번호와 타임스탬프를 같이 보낸다.
만약 1초안, 그니까 3번 틱이 기록되고 60..1..2까지 순회되고 3번 틱이 기록되기 전에 패킷이 도착한다면? 문제 없이 이전 3틱을 기준으로 처리할 수 있을 것이다.
만약 3번틱이 덮어씌워진 상황이라고 해도 타임스탬프를 기반으로 비교하기 때문에, 해당 패킷이 처리되진 않을 것이다.
그럼 이렇게 처리가 되지 않는 패킷은 어떻게 하냐고? 이게 문제다... 문제는 하나의 틱 패킷이 밀렸을 경우 이후 패킷들이 재전송이 될 확률이 엄청 농후하다는 것이다.

게임 상태를 저장하는게 한계가 있다.

틱 패킷을 보낼때 틱번호랑 스탬프를 담아서 보내

배열의 원소가 60개가 있잖아
1초가 지나면 60개가 갱신될거 아니야

이전 1초를 기반으로 한 패킷이왔다면?
index 3
3을 참조해서 처리